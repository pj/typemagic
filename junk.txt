
import { Float, Int } from "type-graphql";
import { RegisteredResolver } from "./query";
import { AddNull, Constructor, GenerateScalarReturnType, HandleItem, IntOrFloat, RegisteredEnum, ScalarTypes } from "./types";

export type IsNull<O> = null extends O ? true : false;
export type IncludeNull<O> = null extends O ? null : never;

export type ArrayNullType<Arr> = 
  Arr extends Array<infer Item> 
    ? (null extends Item ? "nullable_items" : true) 
    : false

export type ResolverTypes<R, C, Item, Original> =
  null extends Item
    ?  (
        RegisteredResolver<R, C, any, Item, true, ArrayNullType<Original>> 
          & {
            nullable: true, 
            array: ArrayNullType<Original>
            //  Original extends Array<infer Z> 
            //   ? (null extends Item ? "nullable_items" : true) 
            //   : false,
            resolve: (args: any, root: R, context: C) => Promise<GenerateScalarReturnType<Item, true, ArrayNullType<Original>>>
          }
        ) | (
          RegisteredOutputObject<C, Item | IncludeNull<Item>>
            & {nullable: true, array: false}
        ) | IncludeNull<Original>
    : (
    RegisteredResolver<R, C, any, Item, false, ArrayNullType<Item>> 
      & {
        nullable: false, 
        array: ArrayNullType<Original>
        // Original extends Array<infer Z> 
        //   ? (null extends Item ? "nullable_items" : true) 
        //   : false,
        resolve: (args: any, root: R, context: C) => Promise<GenerateScalarReturnType<Item, false, ArrayNullType<Item>>>
      }
    ) | (
      RegisteredOutputObject<C, Item | IncludeNull<Item>>
        & {nullable: false | undefined, array: false}
    ) | IncludeNull<Original>

export type HandleArray<R, C, Arr> =
  Arr extends Array<infer X> 
    // ? HandleItem<X> extends never
    //   ? ResolverTypes<R, C, Array<X> | AddNull<Original>>
    //   : (
    //       Array<
    //         HandleItem<X>
    //       > | AddNull<Original>
    //     )
    //     | ResolverTypes<R, C, Array<X> | AddNull<Original>>
    //ResolverTypes<R, C, HandleItem<X> extends never ? HandleItem<X> : X, Arr>
    ?  (RegisteredResolver<
        R, 
        C, 
        any, 
        HandleItem<X> extends never ? X : HandleItem<X>, 
        IsNull<Arr>, ArrayNullType<Arr>
      > & {
          nullable: IsNull<Arr>, 
          array: ArrayNullType<Arr>,
          resolve: (args: any, root: R, context: C) => Promise<GenerateScalarReturnType<X, IsNull<Arr>, ArrayNullType<Arr>>>
        }
      ) | (
        RegisteredOutputObject<C, HandleItem<X> extends never ? HandleItem<X> : X>
          & {nullable: IsNull<Arr>, array: ArrayNullType<Arr>}
      )
    : null extends Arr
      ?  (
          RegisteredResolver<
            R, 
            C, 
            any, 
            HandleItem<Arr> extends never ? Arr : HandleItem<Arr>, 
            IsNull<Arr>, 
            ArrayNullType<Arr>
          > & {
              nullable: IsNull<Arr>, 
              array: ArrayNullType<Arr>,
              resolve: (args: any, root: R, context: C) => Promise<GenerateScalarReturnType<Arr, IsNull<Arr>, ArrayNullType<Arr>>>
            }
        ) | (
          RegisteredOutputObject<C, HandleItem<Arr> extends never ? HandleItem<Arr> : Arr>
            & {nullable: IsNull<Arr>, array: ArrayNullType<Arr>}
        )
      : (
          RegisteredResolver<
            R, 
            C, 
            any, 
            HandleItem<Arr> extends never ? Arr : HandleItem<Arr>, 
            IsNull<Arr>, 
            ArrayNullType<Arr>
          > & {
              nullable: IsNull<Arr>, 
              array: ArrayNullType<Arr>,
              resolve: (args: any, root: R, context: C) => Promise<GenerateScalarReturnType<Arr, IsNull<Arr>, ArrayNullType<Arr>>>
            }
        ) | (
          RegisteredOutputObject<C, HandleItem<Arr> extends never ? HandleItem<Arr> : Arr>
            & {nullable: IsNull<Arr>, array: ArrayNullType<Arr>}
        ) | HandleItem<Arr>
      
      
      // ResolverTypes<R, C, HandleItem<Arr> extends never ? HandleItem<Arr> : Arr, Arr>
      // : ResolverTypes<R, C, HandleItem<Arr> extends never ? HandleItem<Arr> : Arr, Arr> | HandleItem<Arr>
    
    // null extends X
    //   ? HandleItem<X> extends never
    //     ? RegisteredResolver<
    //         R, 
    //         C, 
    //         any, 
    //         Arr
    //       > & {nullable: true, array: "nullable_items", resolve: (args: any, root: R, context: C) => Promise<Array<X | null> | null>}
    //       | (RegisteredOutputObject<C, Arr | null> & {nullable: true, array: false})
    //     : RegisteredResolver<
    //         R, 
    //         C, 
    //         any, 
    //         Arr
    //       > & {nullable: true, array: "nullable_items", resolve: (args: any, root: R, context: C) => Promise<HandleItem<Arr> | null>}
    //       | (RegisteredOutputObject<C, HandleItem<Arr> | null> & {nullable: true, array: false})
    //   : HandleItem<Arr> extends never
    //     ? RegisteredResolver<
    //         R, 
    //         C, 
    //         any, 
    //         Arr
    //       > & {nullable: false, array: false, resolve: (args: any, root: R, context: C) => Promise<Arr>}
    //       | (RegisteredOutputObject<C, Arr | null> & {nullable: false, array: false})
    //     : HandleItem<Arr> 
    //       | RegisteredResolver<
    //           R, 
    //           C, 
    //           any, 
    //           Arr
    //         > & {nullable: false, array: false, resolve: (args: any, root: R, context: C) => Promise<HandleItem<Arr>>}
    //       | (RegisteredOutputObject<C, HandleItem<Arr> | null> & {nullable: false, array: false})
    // : HandleItem<Arr> extends never
    //   ? (
    //       RegisteredResolver<R, C, any, Arr> 
    //       & {
    //         nullable: null extends Arr ? true : false, 
    //         array: false,
    //         resolve: (args: any, root: R, context: C) => Promise<Arr | (null extends Arr ? null : never)>
    //       }
    //     ) | (
    //       RegisteredOutputObject<C, Arr | (null extends Arr ? null : never)> 
    //       & {nullable: null extends Arr ? true : false, array: false}
    //     )
      
      // RegisteredResolver<
      //       R, 
      //       C, 
      //       any, 
      //       Arr
      //     > & {nullable: true, array: false, resolve: (args: any, root: R, context: C) => Promise<Arr | null>}
      //     | (RegisteredOutputObject<C, Arr | null> & {nullable: true, array: false})
      //   : RegisteredResolver<
      //       R, 
      //       C, 
      //       any, 
      //       Arr
      //     > & {nullable: true, array: false, resolve: (args: any, root: R, context: C) => Promise<HandleItem<Arr> | null>}
      //     | (RegisteredOutputObject<C, HandleItem<Arr> | null> & {nullable: true, array: false})
      // : HandleItem<Arr> extends never
      //   ? RegisteredResolver<
      //       R, 
      //       C, 
      //       any, 
      //       Arr
      //     > & {nullable: false, array: false, resolve: (args: any, root: R, context: C) => Promise<Arr>}
      //     | (RegisteredOutputObject<C, Arr | null> & {nullable: false, array: false})
      //   : HandleItem<Arr> 
      //     | RegisteredResolver<
      //         R, 
      //         C, 
      //         any, 
      //         Arr
      //       > & {nullable: false, array: false, resolve: (args: any, root: R, context: C) => Promise<HandleItem<Arr>>}
      //     | (RegisteredOutputObject<C, HandleItem<Arr> | null> & {nullable: false, array: false})

export type OutputRuntimeTypes<R, C, Obj> = {
  // Treat a field being undefined as meaning "Not present in output".
  [FieldName in keyof Obj]?: 
    // Detect String Enums by extend string but string doesn't extend an enum
    Obj[FieldName] extends Array<infer X> 
      ?  (RegisteredResolver<
          R, 
          C, 
          any, 
          HandleItem<X> extends never ? X : HandleItem<X>, 
          IsNull<Obj[FieldName]>, ArrayNullType<Obj[FieldName]>
        > & {
            nullable: IsNull<Obj[FieldName]>, 
            array: ArrayNullType<Obj[FieldName]>,
            resolve: (args: any, root: R, context: C) => Promise<GenerateScalarReturnType<X, IsNull<Obj[FieldName]>, ArrayNullType<Obj[FieldName]>>>
          }
        ) | (
          RegisteredOutputObject<C, HandleItem<X> extends never ? HandleItem<X> : X>
            & {nullable: IsNull<Obj[FieldName]>, array: ArrayNullType<Obj[FieldName]>}
        )
      : null extends Obj[FieldName]
        ?  (
            RegisteredResolver<
              R, 
              C, 
              any, 
              HandleItem<Obj[FieldName]> extends never ? Obj[FieldName] : HandleItem<Obj[FieldName]>, 
              IsNull<Obj[FieldName]>, 
              ArrayNullType<Obj[FieldName]>
            > & {
                nullable: IsNull<Obj[FieldName]>, 
                array: ArrayNullType<Obj[FieldName]>,
                resolve: (args: any, root: R, context: C) => Promise<GenerateScalarReturnType<Obj[FieldName], IsNull<Obj[FieldName]>, ArrayNullType<Obj[FieldName]>>>
              }
          ) | (
            RegisteredOutputObject<C, HandleItem<Obj[FieldName]> extends never ? HandleItem<Obj[FieldName]> : Obj[FieldName]>
              & {nullable: IsNull<Obj[FieldName]>, array: ArrayNullType<Obj[FieldName]>}
          )
        : (
            RegisteredResolver<
              R, 
              C, 
              any, 
              HandleItem<Obj[FieldName]> extends never ? Obj[FieldName] : HandleItem<Obj[FieldName]>, 
              IsNull<Obj[FieldName]>, 
              ArrayNullType<Obj[FieldName]>
            > & {
                nullable: IsNull<Obj[FieldName]>, 
                array: ArrayNullType<Obj[FieldName]>,
                resolve: (args: any, root: R, context: C) => Promise<GenerateScalarReturnType<Obj[FieldName], IsNull<Obj[FieldName]>, ArrayNullType<Obj[FieldName]>>>
              }
          ) | (
            RegisteredOutputObject<C, HandleItem<Obj[FieldName]> extends never ? HandleItem<Obj[FieldName]> : Obj[FieldName]>
              & {nullable: IsNull<Obj[FieldName]>, array: ArrayNullType<Obj[FieldName]>}
          ) | HandleItem<Obj[FieldName]>
} 
// & 
// // Arbitrary properties are allowed.
// {
//   [Key in string]: 
//     keyof Obj extends Key
//       ? () => 
//         Nullable<ScalarTypes> 
//         | ScalarTypes 
//         | Nullable<RegisteredOutputObject<C, any>> 
//         | RegisteredOutputObject<C, any>
//         | RegisteredEnum<{[key: string]: string}>
//         | RegisteredEnum<{[key: number]: string}>
//         | RegisteredQuery<R, C, any, any>
//         | RegisteredResolver<R, C, any>
//       : never
// };

export type OutputObject<C, O> = {
  name?: string,
  type: Constructor<O> | ScalarTypes,
  fieldTypes: OutputRuntimeTypes<O, C, O>,
  nullable?: boolean,
  array?: boolean | "nullable_items",
};

export type RegisteredOutputObject<C, O> = OutputObject<C, O> & {registered: true};

// export class RegisteredOutputObject<C, O> {
//   name?: string;
//   source: Constructor<O>;
//   fieldTypes: OutputRuntimeTypes<O, C, O>;

//   constructor(
//     source: Constructor<O>,
//     fieldTypes: OutputRuntimeTypes<O, C, O>,
//     name?: string,
//   ) {
//     this.name = name;
//     this.source = source;
//     this.fieldTypes = fieldTypes;
//   }
// }

export function object<C, O>(object: OutputObject<C, O>): RegisteredOutputObject<C, O> {
  return {...object, registered: true};
}

// export function nullable<O, C = any>(
//   type: ScalarTypes | Constructor<O> | OutputObject<C, O>
// ): RegisteredOutputObject<C, Constructor<O> | ScalarTypes | null> {
//   if (type === Date || type === Int || type === Float || type === String) {
//     return (
//       {
//         registered: true,
//         type: type,
//         fieldTypes: {},
//         nullable: true
//       }
//     );
//   } else {
//     return ({
//       ...type,
//       nullable: true,
//       registered: true
//     })
//   }
// }

import { RegisteredArgsObject } from "./args";
import { RegisteredOutputObject } from "./output"
import { GenerateScalarReturnType, ScalarTypes } from "./types";

export type RegisteredOutputWithScalars<C, O>  = RegisteredOutputObject<C, O> | ScalarTypes;

// export type Query<R, C, A, O> = {
//   name?: string,
//   resolve: ObjectQuery<R, C, A, O>
//   output: RegisteredOutputWithScalars<C, O>
//   args: RegisteredArgsObject<A>
// }

// export type ObjectQuery<R, C, A, O> = (args: A, root: R, context: C) => Promise<O>;

// export class RegisteredQuery<R, C, A, O> {
//   name?: string;
//   resolve: ObjectQuery<R, C, A, O>;
//   output: RegisteredOutputWithScalars<C, O>;
//   args: RegisteredArgsObject<A>;

//   constructor(
//     resolve: ObjectQuery<R, C, A, O>, 
//     output: RegisteredOutputWithScalars<C, O>, 
//     args: RegisteredArgsObject<A>, 
//     name?: string
//   ) {
//     this.resolve = resolve;
//     this.output = output;
//     this.args = args;
//     this.name = name;
//   }
// }

// export function query<R, A, O, C = any>(query: Query<R, C, A, O>): RegisteredQuery<R, C, A, O> {
//   return new RegisteredQuery(query.resolve, query.output, query.args, query.name);
// }

// FIXME: O | null isn't really correct, but I can't think of how to handle this right now.
export type Resolve<R, C, O> = (root: R, context: C) => Promise<O | null>;

export type Resolver<R, C, A, O, N extends boolean, Arr extends boolean | "nullable_items"> = {
  args?: RegisteredArgsObject<A>
  type: RegisteredOutputWithScalars<C, O>,
  nullable?: N,
  array?: Arr,
  name?: string,
  description?: string,
  deprecationReason?: string,
  resolve: (args: A, root: R, context: C) => Promise<GenerateScalarReturnType<O, N, Arr>>
}

export type RegisteredResolver<R, C, A, O, N extends boolean, Arr extends boolean | "nullable_items"> = 
  Resolver<R, C, A, O, N, Arr> & {registered: true};

// FIXME: resolver is separate from query because I couldn't find a way to make args dependant on the type of the 
// resolve function
export function query<R, A, O, N extends boolean, Arr extends boolean | "nullable_items", C = any>(
  query: Resolver<R, C, A, O, N, Arr>
): RegisteredResolver<R, C, A, O, N, Arr> {
  return {...query, registered: true};
}

// FIXME: O[] | null isn't really correct, but I can't think of how to handle this right now.
// export type ArrayResolveFunction<R, C, O> = (root: R, context: C) => Promise<O[] | null>;

// export type ArrayResolver<R, C, O> = {
//   name?: string,
//   resolve: ArrayResolveFunction<R, C, O>
//   output: RegisteredOutputWithScalars<C, O>
// }

// export type ArrayResolver<C, O> = {
//   nullable?: boolean,
//   type: RegisteredOutputWithScalars<C, O>
// }

// export function array<R, O, C = any>(array: ScalarTypes | ArrayResolver<C, O>): RegisteredOutputObject<R, C, O> {
//   return {...array, array: true}
// }

// export class RegisteredResolver<R, C, O> {
//   name?: string;
//   resolve: Resolve<R, C, O> | ArrayResolveFunction<R, C, O>
//   output: RegisteredOutputWithScalars<C, O>

//   constructor(resolve: Resolve<R, C, O> | ArrayResolveFunction<R, C, O>, output: RegisteredOutputWithScalars<C, O>, name?: string) {
//     this.resolve = resolve;
//     this.output = output;
//     this.name = name;
//   }
// 

// export type Resolver<R, C, A, O> = 
//   ResolverCommon<C, A, O> 
//     & {
//       resolve: (args: A, root: R, context: C) => O | null
//     } 
  // | ResolverCommon<C, A, O> 
  //   & {
  //     nullable: false, 
  //     array: undefined,
  //     resolve: (args: A, root: R, context: C) => O
  //   } 
  // | ResolverCommon<C, A, O> 
  //   & {
  //     nullable: true, 
  //     array: true
  //     resolve: (args: A, root: R, context: C) => O[] | null
  //   } 
  // | ResolverCommon<C, A, O> 
  //   & {
  //     nullable: false, 
  //     array: true
  //     resolve: (args: A, root: R, context: C) => O[]
  //   } 

// type Context = {someContext: string};
// type RelatedType = RelatedClass | null

// type X = [UnderlyingIsScalar<RelatedType>] extends [false] ? true : false

// type RelatedResolver = Resolver<Test, Context, Args, RelatedType>
// type ResolverFunction = RelatedResolver["resolve"]
// type RelatedRuntimeTypes = RelatedResolver["runtimeTypes"];
// type TestFieldResolver = RelatedRuntimeTypes["testField"]
// type ResolverArgs = RelatedResolver["args"]

// export type TestResolution<Context, OutputType> = 
//   {
//     [FieldName in keyof OutputType]?: 
//       Resolver<OutputType, Context, OutputType[FieldName]>
//   }

// export type TestDiscrimant<Type> = Type extends any ? Type : Type

// type A = TestDiscrimant<Test>

// type Y = TestResolution<Context, Test>
// type Z = Exclude<Y["dateField"], undefined>["resolve"]

const resolved = {
  type: Test,
  resolve: resolver({
    resolve: testObject,
    args: registeredArgs,
  }),
  runtimeTypes: {
    stringField: {
      type: String,
      resolve: resolver({
        args: {
          type: ChildArgs,
          runtimeTypes: {
            field: {type: String}
          }
        },
        resolve: async (args: ChildArgs, root: Test, context: any) => {
          return `asdf`;
        }
      })
    }
  }
}

// type TestType = {
//   field: string,
//   anotherField: boolean
// };

// type TestArgsInfer<Type, Args> = 
//   { 
//     resolve: (args: Args) => Type,
//     args: Args
//   }

// type MapTest<Args> = {
//   [Key in keyof TestType]:
//     TestArgsInfer<TestType[Key], Args>
// }

// function map<Args>(mt: MapTest<Args>): void {

// }

// map({
//   field: {
//     resolve: (args: number) => "hello", 
//     args: 1
//   },
//   anotherField: {
//     resolve: (args: string) => true, 
//     args: "world"
//   }
// }

// type TestType = {
//   field: string,
//   anotherField: boolean
// };

// type TestArgsInfer<Type, Args> = 
//   { 
//     resolve: (args: Args) => Type,
//     args: Args
//   }

// type MapTest = {
//   [Key in keyof TestType]:
//     <Args> () => TestArgsInfer<TestType[Key], Args>
// }

// function map(mt: MapTest): void {

// }

// map({
//   field: () => ({
//     resolve: (args: number) => "hello", 
//     args: 1
//   }),
//   anotherField: () => ({
//     resolve: (args: string) => true, 
//     args: "world"
//   })
// })


// type From = {
//   field: string,
//   anotherField: boolean
// };


// type MapTest = {
//   [Key in keyof From]:
//     <Args> (args: Args) => From[Key]
// }

// function map(mt: MapTest): void {

// }

// map({
//   field: (args: number) => "hello", 
//   anotherField: (args: string) => true
// })

type TestType = {
  field: string,
  anotherField: boolean
};

// type X = {
//   [K in keyof TestType]: TestType[K]
// }[string]

// type SimpleTransform<X> = {asdf: X} 

// type VariadicAndWithTransform<T extends any[]> = 
//   {
//     [K in keyof T]: (v: SimpleTransform<T[K]>) => void
//   }[number] extends ((v: infer I) => void) ? I : never

// type Z = VariadicAndWithTransform<[{a: 1}, {b: 2}]>

// type ValueOf<T> = T[keyof T];

// type NonEmptyArray<T> = [T, ...T[]]

// type MustInclude<T, U extends T[]> = [T] extends [ValueOf<U>] ? U : never;

// type X = ValueOf<TestType>
// type Y = NonEmptyArray<keyof TestType>

// type X = (...args: TestType) => void extends 
// type X = {
//   [Key in keyof TestType as ]: (args: Args) => TestType[Key]
//   j
// }

// type ArgsSchema<Args> = 
//   Args extends string 
//     ? "string" 
//     : Args extends number 
//       ? "number" 
//       : Args extends Date
//         ? typeof Date
//         : never

// type From = {
//   field: string,
//   anotherField: boolean
// }

// // Map it to
// type To = {
//   field: {
//     resolve: (args: number) => string,
//     argsSchema: ArgsSchema<number>
//   },
//   anotherField: {
//     resolve: (args: Date) => boolean
//     argsSchema: ArgsSchema<Date>
//   }
// }

// // For an object like
// const to = {
//   field: {
//     resolve: (args: number) => `Hello number ${args}`,
//     argsSchema: "string"
//   },
//   anotherField: 
//   {
//     resolve: (args: Date) => args.getSeconds() > 10,
//     argsSchema: Date
//   }
// }


// // Example 1

// type MapTest = {
//   [Key in keyof From]: {
//     resolve: (args: X) => From[Key],
//     argsSchema: From[Key]
//   }
// }

// function map(mt: MapTest): void {

// }

// map({
//   field: {
//     resolve: (args: number) => "hello", 
//     argsSchema: "number" 
//   },
//   anotherField: { 
//     resolve: (args: string) => true, 
//     argsSchema: "string" 
//   }
// })

// // Example 2
// // type MapTest2 = {
// //   [Key in keyof From]: {
// //     resolve: <Args> (args: Args) => From[Key],
// //     argsSchema: ArgsSchema<Args>
// //   }
// // }

// // function map2(mt: MapTest2): void {

// // }

// // map2({
// //   field: {
// //     resolve: (args: number) => "hello", 
// //     argsSchema: "number" 
// //   },
// //   anotherField: { 
// //     resolve: (args: string) => true, 
// //     argsSchema: "string" 
// //   }
// // })


// export type GetCompileTimeScalarType<Item> =
//   [Item] extends [typeof Date] 
//     ? Date
//     : [Item] extends [typeof Boolean]
//       ? boolean
//       : [Item] extends [typeof String]
//         ? string
//         : [Item] extends [IntOrFloat]
//           ? number
//         //   : [Item] extends [RegisteredEnum<{[key: string]: string}>]
//         // : [Item] extends [number]
//         //   ? IntOrFloat | RegisteredEnum<{[key: number]: string}>
//           : never

export type RuntimeArgsType<Item, B extends BooleanOrUndefined, A extends ArrayTrilean> =
  { 
    type: Item,
    nullable?: B,
    array?: A
  } 

// export type ArgsTypeFromRuntime<Item, Nullability extends BooleanOrUndefined, IsArray extends ArrayTrilean> =
//   GenerateReturnType<GetCompileTimeScalarType<Item>, Nullability, IsArray>

export type InferArgsFromSchema<Item, Nullability extends BooleanOrUndefined, IsArray extends ArrayTrilean> = 
  { 
    type: Item,
    nullable?: Nullability,
    array?: IsArray
  } 
    // & (
    //     [Item] extends [ScalarTypes]
    //     ? {}
    //     : {
    //         name?: string,
    //         runtimeTypes: InputRuntimeTypes<Item>
    //       }
    //   )


export type ArgsRuntimeTypes<Obj> = {
  [FieldName in keyof Obj]: 
    ScalarOrInput<Obj[FieldName]>
} 

export type ArgsSchema<O> = {
  type: Constructor<O>,
  runtimeSchema: ArgsRuntimeTypes<O>,
};

export type InferArgsForType<
  Type, 
  InferedArgs
> = {
  [FieldName in keyof InferedArgs]: 
    [FieldName] extends [keyof Type] 
      ? InferedArgs[FieldName]
      : never
}


// export type ResolverFunction<InferedArg, ReturnType> = 
//   [InferedArg] extends [RuntimeArgsType<infer RuntimeType, infer Nullability, infer IsArray>]
//     ? (args: GenerateReturnType<GetCompileTimeScalarType<RuntimeType>, Nullability, IsArray>) => ReturnType
//     : () => ReturnType


// export type ArgsThing<Type> = {
//   [Key in keyof Type]: any
// }

export type ArgsAndResolvers<ResolverFunction, Root, Context> =
  [ResolverFunction] extends [(args: infer ArgsRealType, root: infer X, context: Context) => infer ResponseType]
  ?
    {
      type: [IsCompileTimeScalarType<ResponseType>] extends [true]
        ? GetRuntimeScalarType<ResponseType>
        : Constructor<GetUnderlyingArrayType<ResponseType>>
    } 
    & (
        [null] extends [ResponseType]
          ? {
              nullable: true
            }
          : {
              nullable?: false
            }
      )
    & 
      (
        [undefined] extends [ArgsRealType] 
          ? {}
          : {
              args: {
                type: GetRuntimeScalarType<ArgsRealType>,
              } 
                & 
                  (
                    [null] extends [ArgsRealType] 
                      ? {
                          nullable: true
                        }
                      : {
                          nullable?: false
                      }
                  ),
            }
        )
      & {
          resolve: ResolverFunction,// (args: ArgsRealType) => ResponseType
        } 
      & 
        (
          [IsCompileTimeScalarType<ResponseType>] extends [true]
            ? {}
            : 
              {
                runtimeTypes: {
                  [Key in keyof GetUnderlyingArrayType<ResponseType>]:
                    ArgsAndResolvers<
                      (args: never, root: GetUnderlyingArrayType<ResponseType>, context: Context) => GetUnderlyingArrayType<ResponseType>[Key],
                      GetUnderlyingArrayType<ResponseType>,
                      Context
                    >
              }
            } 
        )
  : "Could not determine parameters from type"

export type ResolverFunction<Root, Context, Args, OutputType> =
  [unknown] extends [Args] 
    ? (root: Root, context: Context) => Promise<OutputType> 
    : { 
        resolve: (args: Args, root: Root, context: Context) => Promise<OutputType>,
        args: ArgsSchema<Args>
      }

export type Resolver<Root, Context, Args, OutputType> = 
  ({
    name?: string,
    description?: string, 
    deprecationReason?: string,
    type: GetRuntimeType<OutputType>
  })
    & GenerateNullabilityAndArrayRuntimeOptions<OutputType> 
    & (
      [unknown] extends [Args] 
        ? {
            resolve: (root: Root, context: Context) => Promise<OutputType> 
          }
        : { 
            resolve: (args: Args, root: Root, context: Context) => Promise<OutputType>,
            args: ArgsSchema<Args>
          }
    )
    & (
        [IsCompileTimeScalar<OutputType>] extends [false] 
          ? {
              runtimeTypes: {
                [FieldName in keyof OutputType]?: 
                  Resolver<OutputType, Context, unknown, OutputType[FieldName]>
              }
            }
          : {}
      )
  
// // Arbitrary properties are allowed.
// {
//   [Key in string]: 
//     keyof Obj extends Key
//       ? () => 
//         Nullable<ScalarTypes> 
//         | ScalarTypes 
//         | Nullable<RegisteredOutputObject<C, any>> 
//         | RegisteredOutputObject<C, any>
//         | RegisteredEnum<{[key: string]: string}>
//         | RegisteredEnum<{[key: number]: string}>
//         | RegisteredQuery<R, C, any, any>
//         | RegisteredResolver<R, C, any>
//       : never
// };

// export type ResolverInput<Root, Context, Args, OutputType> = 
//   ResolverCommon<Context, OutputType> 
//     & ResolverFunction<Root, Context, Args, OutputType>

export function resolver<Root, Context, Args, OutputType>(
  resolver: ResolverFunction<Root, Context, Args, OutputType>
): any
 {
  return resolver;
}

    ? [unknown] extends [ResolverFunction] 
      ? {resolve?: never, args?: never}
export type ValidateRuntimeField<Field, Root, Context> =
  GenerateNullabilityAndArrayRuntimeOptions<Field>

export type ValidateResolverRuntimeTypes<TypeConstructor, ResolverFunction, Root, Context> =
    [TypeConstructor] extends [ScalarTypes]
      ? {
          type: TypeConstructor,
          runtimeTypes?: never
        }
      : [unknown] extends [ResolverFunction]
        ? {
            type: TypeConstructor, 
            runtimeTypes: {
              [Key in keyof CompileTimeTypeFromConstructor<TypeConstructor>]?:
                ValidateRuntimeField<
                  CompileTimeTypeFromConstructor<TypeConstructor>[Key], 
                  CompileTimeTypeFromConstructor<TypeConstructor>, 
                  Context
                >
            }
          }
        : [ResolverFunction] extends [(first: infer First, second: infer Second, third: infer Third) => infer ReturnType]
          ? {
              type: Constructor<ReturnType>, 
              runtimeTypes: {
                [Key in keyof ReturnType]?:
                  ValidateRuntimeField<ReturnType[Key], ReturnType, Context>
              }
            }
          : {
              type: "Invalid Resolver"
            }

import { Args } from "./test"

// export type ValidateResolverFunction<ResolverFunction, ArgsType, Root> =
//   [unknown] extends [ArgsType]
//     ? [unknown] extends [ResolverFunction]
//       ? { resolve?: never, args?: never }
//       : {
//           resolve: (root: Root)
//             => [ResolverFunction] extends [(...args: infer X) => infer ReturnType]
//             ? ReturnType
//             : never,
//           args?: never
//         }
//     : {
//         resolve: (
//           args: ArgsType,
//           root: Root
//         ) => [ResolverFunction] extends [(...args: infer X) => infer ReturnType]
//           ? ReturnType
//           : never,
//         args: ArgsType
//       }

export type ValidateResolverFunction<ResolverFunction, ArgsType, Root> =
    [unknown] extends [ResolverFunction]
      ? unknown
      : [ResolverFunction] extends [(first: infer First, second: infer Second) => infer ReturnType]
        ? [unknown] extends [ArgsType]
          ? ((first: Root) => ReturnType) | (() => ReturnType)
          : ((first: ArgsType, second: Root) => ReturnType) | ((first: ArgsType) => ReturnType) | (() => ReturnType)
        : never
    // : {resolve?: never, args?: never}
  // [unknown] extends [ArgsType]
  //   ? [unknown] extends [ResolverFunction]
  //     ? { resolve?: never, args?: never }
  //     : {
  //         resolve: (root: Root)
  //           => [ResolverFunction] extends [(...args: infer X) => infer ReturnType]
  //           ? ReturnType
  //           : never,
  //         args?: never
  //       }
  //   : {
  //       resolve: (
  //         args: ArgsType,
  //         root: Root
  //       ) => [ResolverFunction] extends [(...args: infer X) => infer ReturnType]
  //         ? ReturnType
  //         : never,
  //       args: ArgsType
  //     }

type X = [{resolve: () => string, args: string}] extends [ValidateResolverFunction<(root: RootType) => string, string, RootType>]
  ? true : false

type Z = ValidateResolverFunction<(root: RootType) => string, string, RootType>

type Y = [() => string] extends [(arg: infer X) => string] ? X : never



export type ValidateResolver<Resolver, Root> =
  [Resolver] extends [{
    args?: infer ArgsType,
    resolve?: infer ResolverFunction
  }]
    ? [unknown] extends [ResolverFunction] 
      ? {resolve?: never, args?: never}
        : [ResolverFunction] extends [ValidateResolverFunction<ResolverFunction, ArgsType, Root>]
          ? [unknown] extends [ArgsType]
            ? {resolve: ResolverFunction, args?: never}
            : {resolve: ResolverFunction, args: ArgsType}
        : ["Invalid resolver function", ValidateResolverFunction<ResolverFunction, ArgsType, Root>]
    : "Can't infer type"


class RootType {}

function testValidate<X extends ValidateResolver<X, RootType>>(x: X) {
  return x;
}

testValidate({
});

testValidate({
  args: "test",
  resolve: (args: string) => {
    return `things`;
  }
});

testValidate({
  resolve: () => {
    return `things`;
  }
});

testValidate({
  // Errors out correctly
  resolve: (args: string, root: RootType) => {
    return `things`;
  }
});

testValidate({
  args: "test",
  // This should error out, since first parameter is not args: string.
  resolve: (root: RootType) => {
    return `things`;
  }
});