
import { Float, Int } from "type-graphql";
import { RegisteredResolver } from "./query";
import { AddNull, Constructor, GenerateScalarReturnType, HandleItem, IntOrFloat, RegisteredEnum, ScalarTypes } from "./types";

export type IsNull<O> = null extends O ? true : false;
export type IncludeNull<O> = null extends O ? null : never;

export type ArrayNullType<Arr> = 
  Arr extends Array<infer Item> 
    ? (null extends Item ? "nullable_items" : true) 
    : false

export type ResolverTypes<R, C, Item, Original> =
  null extends Item
    ?  (
        RegisteredResolver<R, C, any, Item, true, ArrayNullType<Original>> 
          & {
            nullable: true, 
            array: ArrayNullType<Original>
            //  Original extends Array<infer Z> 
            //   ? (null extends Item ? "nullable_items" : true) 
            //   : false,
            resolve: (args: any, root: R, context: C) => Promise<GenerateScalarReturnType<Item, true, ArrayNullType<Original>>>
          }
        ) | (
          RegisteredOutputObject<C, Item | IncludeNull<Item>>
            & {nullable: true, array: false}
        ) | IncludeNull<Original>
    : (
    RegisteredResolver<R, C, any, Item, false, ArrayNullType<Item>> 
      & {
        nullable: false, 
        array: ArrayNullType<Original>
        // Original extends Array<infer Z> 
        //   ? (null extends Item ? "nullable_items" : true) 
        //   : false,
        resolve: (args: any, root: R, context: C) => Promise<GenerateScalarReturnType<Item, false, ArrayNullType<Item>>>
      }
    ) | (
      RegisteredOutputObject<C, Item | IncludeNull<Item>>
        & {nullable: false | undefined, array: false}
    ) | IncludeNull<Original>

export type HandleArray<R, C, Arr> =
  Arr extends Array<infer X> 
    // ? HandleItem<X> extends never
    //   ? ResolverTypes<R, C, Array<X> | AddNull<Original>>
    //   : (
    //       Array<
    //         HandleItem<X>
    //       > | AddNull<Original>
    //     )
    //     | ResolverTypes<R, C, Array<X> | AddNull<Original>>
    //ResolverTypes<R, C, HandleItem<X> extends never ? HandleItem<X> : X, Arr>
    ?  (RegisteredResolver<
        R, 
        C, 
        any, 
        HandleItem<X> extends never ? X : HandleItem<X>, 
        IsNull<Arr>, ArrayNullType<Arr>
      > & {
          nullable: IsNull<Arr>, 
          array: ArrayNullType<Arr>,
          resolve: (args: any, root: R, context: C) => Promise<GenerateScalarReturnType<X, IsNull<Arr>, ArrayNullType<Arr>>>
        }
      ) | (
        RegisteredOutputObject<C, HandleItem<X> extends never ? HandleItem<X> : X>
          & {nullable: IsNull<Arr>, array: ArrayNullType<Arr>}
      )
    : null extends Arr
      ?  (
          RegisteredResolver<
            R, 
            C, 
            any, 
            HandleItem<Arr> extends never ? Arr : HandleItem<Arr>, 
            IsNull<Arr>, 
            ArrayNullType<Arr>
          > & {
              nullable: IsNull<Arr>, 
              array: ArrayNullType<Arr>,
              resolve: (args: any, root: R, context: C) => Promise<GenerateScalarReturnType<Arr, IsNull<Arr>, ArrayNullType<Arr>>>
            }
        ) | (
          RegisteredOutputObject<C, HandleItem<Arr> extends never ? HandleItem<Arr> : Arr>
            & {nullable: IsNull<Arr>, array: ArrayNullType<Arr>}
        )
      : (
          RegisteredResolver<
            R, 
            C, 
            any, 
            HandleItem<Arr> extends never ? Arr : HandleItem<Arr>, 
            IsNull<Arr>, 
            ArrayNullType<Arr>
          > & {
              nullable: IsNull<Arr>, 
              array: ArrayNullType<Arr>,
              resolve: (args: any, root: R, context: C) => Promise<GenerateScalarReturnType<Arr, IsNull<Arr>, ArrayNullType<Arr>>>
            }
        ) | (
          RegisteredOutputObject<C, HandleItem<Arr> extends never ? HandleItem<Arr> : Arr>
            & {nullable: IsNull<Arr>, array: ArrayNullType<Arr>}
        ) | HandleItem<Arr>
      
      
      // ResolverTypes<R, C, HandleItem<Arr> extends never ? HandleItem<Arr> : Arr, Arr>
      // : ResolverTypes<R, C, HandleItem<Arr> extends never ? HandleItem<Arr> : Arr, Arr> | HandleItem<Arr>
    
    // null extends X
    //   ? HandleItem<X> extends never
    //     ? RegisteredResolver<
    //         R, 
    //         C, 
    //         any, 
    //         Arr
    //       > & {nullable: true, array: "nullable_items", resolve: (args: any, root: R, context: C) => Promise<Array<X | null> | null>}
    //       | (RegisteredOutputObject<C, Arr | null> & {nullable: true, array: false})
    //     : RegisteredResolver<
    //         R, 
    //         C, 
    //         any, 
    //         Arr
    //       > & {nullable: true, array: "nullable_items", resolve: (args: any, root: R, context: C) => Promise<HandleItem<Arr> | null>}
    //       | (RegisteredOutputObject<C, HandleItem<Arr> | null> & {nullable: true, array: false})
    //   : HandleItem<Arr> extends never
    //     ? RegisteredResolver<
    //         R, 
    //         C, 
    //         any, 
    //         Arr
    //       > & {nullable: false, array: false, resolve: (args: any, root: R, context: C) => Promise<Arr>}
    //       | (RegisteredOutputObject<C, Arr | null> & {nullable: false, array: false})
    //     : HandleItem<Arr> 
    //       | RegisteredResolver<
    //           R, 
    //           C, 
    //           any, 
    //           Arr
    //         > & {nullable: false, array: false, resolve: (args: any, root: R, context: C) => Promise<HandleItem<Arr>>}
    //       | (RegisteredOutputObject<C, HandleItem<Arr> | null> & {nullable: false, array: false})
    // : HandleItem<Arr> extends never
    //   ? (
    //       RegisteredResolver<R, C, any, Arr> 
    //       & {
    //         nullable: null extends Arr ? true : false, 
    //         array: false,
    //         resolve: (args: any, root: R, context: C) => Promise<Arr | (null extends Arr ? null : never)>
    //       }
    //     ) | (
    //       RegisteredOutputObject<C, Arr | (null extends Arr ? null : never)> 
    //       & {nullable: null extends Arr ? true : false, array: false}
    //     )
      
      // RegisteredResolver<
      //       R, 
      //       C, 
      //       any, 
      //       Arr
      //     > & {nullable: true, array: false, resolve: (args: any, root: R, context: C) => Promise<Arr | null>}
      //     | (RegisteredOutputObject<C, Arr | null> & {nullable: true, array: false})
      //   : RegisteredResolver<
      //       R, 
      //       C, 
      //       any, 
      //       Arr
      //     > & {nullable: true, array: false, resolve: (args: any, root: R, context: C) => Promise<HandleItem<Arr> | null>}
      //     | (RegisteredOutputObject<C, HandleItem<Arr> | null> & {nullable: true, array: false})
      // : HandleItem<Arr> extends never
      //   ? RegisteredResolver<
      //       R, 
      //       C, 
      //       any, 
      //       Arr
      //     > & {nullable: false, array: false, resolve: (args: any, root: R, context: C) => Promise<Arr>}
      //     | (RegisteredOutputObject<C, Arr | null> & {nullable: false, array: false})
      //   : HandleItem<Arr> 
      //     | RegisteredResolver<
      //         R, 
      //         C, 
      //         any, 
      //         Arr
      //       > & {nullable: false, array: false, resolve: (args: any, root: R, context: C) => Promise<HandleItem<Arr>>}
      //     | (RegisteredOutputObject<C, HandleItem<Arr> | null> & {nullable: false, array: false})

export type OutputRuntimeTypes<R, C, Obj> = {
  // Treat a field being undefined as meaning "Not present in output".
  [FieldName in keyof Obj]?: 
    // Detect String Enums by extend string but string doesn't extend an enum
    Obj[FieldName] extends Array<infer X> 
      ?  (RegisteredResolver<
          R, 
          C, 
          any, 
          HandleItem<X> extends never ? X : HandleItem<X>, 
          IsNull<Obj[FieldName]>, ArrayNullType<Obj[FieldName]>
        > & {
            nullable: IsNull<Obj[FieldName]>, 
            array: ArrayNullType<Obj[FieldName]>,
            resolve: (args: any, root: R, context: C) => Promise<GenerateScalarReturnType<X, IsNull<Obj[FieldName]>, ArrayNullType<Obj[FieldName]>>>
          }
        ) | (
          RegisteredOutputObject<C, HandleItem<X> extends never ? HandleItem<X> : X>
            & {nullable: IsNull<Obj[FieldName]>, array: ArrayNullType<Obj[FieldName]>}
        )
      : null extends Obj[FieldName]
        ?  (
            RegisteredResolver<
              R, 
              C, 
              any, 
              HandleItem<Obj[FieldName]> extends never ? Obj[FieldName] : HandleItem<Obj[FieldName]>, 
              IsNull<Obj[FieldName]>, 
              ArrayNullType<Obj[FieldName]>
            > & {
                nullable: IsNull<Obj[FieldName]>, 
                array: ArrayNullType<Obj[FieldName]>,
                resolve: (args: any, root: R, context: C) => Promise<GenerateScalarReturnType<Obj[FieldName], IsNull<Obj[FieldName]>, ArrayNullType<Obj[FieldName]>>>
              }
          ) | (
            RegisteredOutputObject<C, HandleItem<Obj[FieldName]> extends never ? HandleItem<Obj[FieldName]> : Obj[FieldName]>
              & {nullable: IsNull<Obj[FieldName]>, array: ArrayNullType<Obj[FieldName]>}
          )
        : (
            RegisteredResolver<
              R, 
              C, 
              any, 
              HandleItem<Obj[FieldName]> extends never ? Obj[FieldName] : HandleItem<Obj[FieldName]>, 
              IsNull<Obj[FieldName]>, 
              ArrayNullType<Obj[FieldName]>
            > & {
                nullable: IsNull<Obj[FieldName]>, 
                array: ArrayNullType<Obj[FieldName]>,
                resolve: (args: any, root: R, context: C) => Promise<GenerateScalarReturnType<Obj[FieldName], IsNull<Obj[FieldName]>, ArrayNullType<Obj[FieldName]>>>
              }
          ) | (
            RegisteredOutputObject<C, HandleItem<Obj[FieldName]> extends never ? HandleItem<Obj[FieldName]> : Obj[FieldName]>
              & {nullable: IsNull<Obj[FieldName]>, array: ArrayNullType<Obj[FieldName]>}
          ) | HandleItem<Obj[FieldName]>
} 
// & 
// // Arbitrary properties are allowed.
// {
//   [Key in string]: 
//     keyof Obj extends Key
//       ? () => 
//         Nullable<ScalarTypes> 
//         | ScalarTypes 
//         | Nullable<RegisteredOutputObject<C, any>> 
//         | RegisteredOutputObject<C, any>
//         | RegisteredEnum<{[key: string]: string}>
//         | RegisteredEnum<{[key: number]: string}>
//         | RegisteredQuery<R, C, any, any>
//         | RegisteredResolver<R, C, any>
//       : never
// };

export type OutputObject<C, O> = {
  name?: string,
  type: Constructor<O> | ScalarTypes,
  fieldTypes: OutputRuntimeTypes<O, C, O>,
  nullable?: boolean,
  array?: boolean | "nullable_items",
};

export type RegisteredOutputObject<C, O> = OutputObject<C, O> & {registered: true};

// export class RegisteredOutputObject<C, O> {
//   name?: string;
//   source: Constructor<O>;
//   fieldTypes: OutputRuntimeTypes<O, C, O>;

//   constructor(
//     source: Constructor<O>,
//     fieldTypes: OutputRuntimeTypes<O, C, O>,
//     name?: string,
//   ) {
//     this.name = name;
//     this.source = source;
//     this.fieldTypes = fieldTypes;
//   }
// }

export function object<C, O>(object: OutputObject<C, O>): RegisteredOutputObject<C, O> {
  return {...object, registered: true};
}

// export function nullable<O, C = any>(
//   type: ScalarTypes | Constructor<O> | OutputObject<C, O>
// ): RegisteredOutputObject<C, Constructor<O> | ScalarTypes | null> {
//   if (type === Date || type === Int || type === Float || type === String) {
//     return (
//       {
//         registered: true,
//         type: type,
//         fieldTypes: {},
//         nullable: true
//       }
//     );
//   } else {
//     return ({
//       ...type,
//       nullable: true,
//       registered: true
//     })
//   }
// }

import { RegisteredArgsObject } from "./args";
import { RegisteredOutputObject } from "./output"
import { GenerateScalarReturnType, ScalarTypes } from "./types";

export type RegisteredOutputWithScalars<C, O>  = RegisteredOutputObject<C, O> | ScalarTypes;

// export type Query<R, C, A, O> = {
//   name?: string,
//   resolve: ObjectQuery<R, C, A, O>
//   output: RegisteredOutputWithScalars<C, O>
//   args: RegisteredArgsObject<A>
// }

// export type ObjectQuery<R, C, A, O> = (args: A, root: R, context: C) => Promise<O>;

// export class RegisteredQuery<R, C, A, O> {
//   name?: string;
//   resolve: ObjectQuery<R, C, A, O>;
//   output: RegisteredOutputWithScalars<C, O>;
//   args: RegisteredArgsObject<A>;

//   constructor(
//     resolve: ObjectQuery<R, C, A, O>, 
//     output: RegisteredOutputWithScalars<C, O>, 
//     args: RegisteredArgsObject<A>, 
//     name?: string
//   ) {
//     this.resolve = resolve;
//     this.output = output;
//     this.args = args;
//     this.name = name;
//   }
// }

// export function query<R, A, O, C = any>(query: Query<R, C, A, O>): RegisteredQuery<R, C, A, O> {
//   return new RegisteredQuery(query.resolve, query.output, query.args, query.name);
// }

// FIXME: O | null isn't really correct, but I can't think of how to handle this right now.
export type Resolve<R, C, O> = (root: R, context: C) => Promise<O | null>;

export type Resolver<R, C, A, O, N extends boolean, Arr extends boolean | "nullable_items"> = {
  args?: RegisteredArgsObject<A>
  type: RegisteredOutputWithScalars<C, O>,
  nullable?: N,
  array?: Arr,
  name?: string,
  description?: string,
  deprecationReason?: string,
  resolve: (args: A, root: R, context: C) => Promise<GenerateScalarReturnType<O, N, Arr>>
}

export type RegisteredResolver<R, C, A, O, N extends boolean, Arr extends boolean | "nullable_items"> = 
  Resolver<R, C, A, O, N, Arr> & {registered: true};

// FIXME: resolver is separate from query because I couldn't find a way to make args dependant on the type of the 
// resolve function
export function query<R, A, O, N extends boolean, Arr extends boolean | "nullable_items", C = any>(
  query: Resolver<R, C, A, O, N, Arr>
): RegisteredResolver<R, C, A, O, N, Arr> {
  return {...query, registered: true};
}

// FIXME: O[] | null isn't really correct, but I can't think of how to handle this right now.
// export type ArrayResolveFunction<R, C, O> = (root: R, context: C) => Promise<O[] | null>;

// export type ArrayResolver<R, C, O> = {
//   name?: string,
//   resolve: ArrayResolveFunction<R, C, O>
//   output: RegisteredOutputWithScalars<C, O>
// }

// export type ArrayResolver<C, O> = {
//   nullable?: boolean,
//   type: RegisteredOutputWithScalars<C, O>
// }

// export function array<R, O, C = any>(array: ScalarTypes | ArrayResolver<C, O>): RegisteredOutputObject<R, C, O> {
//   return {...array, array: true}
// }

// export class RegisteredResolver<R, C, O> {
//   name?: string;
//   resolve: Resolve<R, C, O> | ArrayResolveFunction<R, C, O>
//   output: RegisteredOutputWithScalars<C, O>

//   constructor(resolve: Resolve<R, C, O> | ArrayResolveFunction<R, C, O>, output: RegisteredOutputWithScalars<C, O>, name?: string) {
//     this.resolve = resolve;
//     this.output = output;
//     this.name = name;
//   }
// 

// export type Resolver<R, C, A, O> = 
//   ResolverCommon<C, A, O> 
//     & {
//       resolve: (args: A, root: R, context: C) => O | null
//     } 
  // | ResolverCommon<C, A, O> 
  //   & {
  //     nullable: false, 
  //     array: undefined,
  //     resolve: (args: A, root: R, context: C) => O
  //   } 
  // | ResolverCommon<C, A, O> 
  //   & {
  //     nullable: true, 
  //     array: true
  //     resolve: (args: A, root: R, context: C) => O[] | null
  //   } 
  // | ResolverCommon<C, A, O> 
  //   & {
  //     nullable: false, 
  //     array: true
  //     resolve: (args: A, root: R, context: C) => O[]
  //   } 

// type Context = {someContext: string};
// type RelatedType = RelatedClass | null

// type X = [UnderlyingIsScalar<RelatedType>] extends [false] ? true : false

// type RelatedResolver = Resolver<Test, Context, Args, RelatedType>
// type ResolverFunction = RelatedResolver["resolve"]
// type RelatedRuntimeTypes = RelatedResolver["runtimeTypes"];
// type TestFieldResolver = RelatedRuntimeTypes["testField"]
// type ResolverArgs = RelatedResolver["args"]

// export type TestResolution<Context, OutputType> = 
//   {
//     [FieldName in keyof OutputType]?: 
//       Resolver<OutputType, Context, OutputType[FieldName]>
//   }

// export type TestDiscrimant<Type> = Type extends any ? Type : Type

// type A = TestDiscrimant<Test>

// type Y = TestResolution<Context, Test>
// type Z = Exclude<Y["dateField"], undefined>["resolve"]

const resolved = {
  type: Test,
  resolve: resolver({
    resolve: testObject,
    args: registeredArgs,
  }),
  runtimeTypes: {
    stringField: {
      type: String,
      resolve: resolver({
        args: {
          type: ChildArgs,
          runtimeTypes: {
            field: {type: String}
          }
        },
        resolve: async (args: ChildArgs, root: Test, context: any) => {
          return `asdf`;
        }
      })
    }
  }
}

// type TestType = {
//   field: string,
//   anotherField: boolean
// };

// type TestArgsInfer<Type, Args> = 
//   { 
//     resolve: (args: Args) => Type,
//     args: Args
//   }

// type MapTest<Args> = {
//   [Key in keyof TestType]:
//     TestArgsInfer<TestType[Key], Args>
// }

// function map<Args>(mt: MapTest<Args>): void {

// }

// map({
//   field: {
//     resolve: (args: number) => "hello", 
//     args: 1
//   },
//   anotherField: {
//     resolve: (args: string) => true, 
//     args: "world"
//   }
// }

// type TestType = {
//   field: string,
//   anotherField: boolean
// };

// type TestArgsInfer<Type, Args> = 
//   { 
//     resolve: (args: Args) => Type,
//     args: Args
//   }

// type MapTest = {
//   [Key in keyof TestType]:
//     <Args> () => TestArgsInfer<TestType[Key], Args>
// }

// function map(mt: MapTest): void {

// }

// map({
//   field: () => ({
//     resolve: (args: number) => "hello", 
//     args: 1
//   }),
//   anotherField: () => ({
//     resolve: (args: string) => true, 
//     args: "world"
//   })
// })


// type From = {
//   field: string,
//   anotherField: boolean
// };


// type MapTest = {
//   [Key in keyof From]:
//     <Args> (args: Args) => From[Key]
// }

// function map(mt: MapTest): void {

// }

// map({
//   field: (args: number) => "hello", 
//   anotherField: (args: string) => true
// })

type TestType = {
  field: string,
  anotherField: boolean
};

// type X = {
//   [K in keyof TestType]: TestType[K]
// }[string]

// type SimpleTransform<X> = {asdf: X} 

// type VariadicAndWithTransform<T extends any[]> = 
//   {
//     [K in keyof T]: (v: SimpleTransform<T[K]>) => void
//   }[number] extends ((v: infer I) => void) ? I : never

// type Z = VariadicAndWithTransform<[{a: 1}, {b: 2}]>

// type ValueOf<T> = T[keyof T];

// type NonEmptyArray<T> = [T, ...T[]]

// type MustInclude<T, U extends T[]> = [T] extends [ValueOf<U>] ? U : never;

// type X = ValueOf<TestType>
// type Y = NonEmptyArray<keyof TestType>

// type X = (...args: TestType) => void extends 
// type X = {
//   [Key in keyof TestType as ]: (args: Args) => TestType[Key]
//   j
// }

// type ArgsSchema<Args> = 
//   Args extends string 
//     ? "string" 
//     : Args extends number 
//       ? "number" 
//       : Args extends Date
//         ? typeof Date
//         : never

// type From = {
//   field: string,
//   anotherField: boolean
// }

// // Map it to
// type To = {
//   field: {
//     resolve: (args: number) => string,
//     argsSchema: ArgsSchema<number>
//   },
//   anotherField: {
//     resolve: (args: Date) => boolean
//     argsSchema: ArgsSchema<Date>
//   }
// }

// // For an object like
// const to = {
//   field: {
//     resolve: (args: number) => `Hello number ${args}`,
//     argsSchema: "string"
//   },
//   anotherField: 
//   {
//     resolve: (args: Date) => args.getSeconds() > 10,
//     argsSchema: Date
//   }
// }


// // Example 1

// type MapTest = {
//   [Key in keyof From]: {
//     resolve: (args: X) => From[Key],
//     argsSchema: From[Key]
//   }
// }

// function map(mt: MapTest): void {

// }

// map({
//   field: {
//     resolve: (args: number) => "hello", 
//     argsSchema: "number" 
//   },
//   anotherField: { 
//     resolve: (args: string) => true, 
//     argsSchema: "string" 
//   }
// })

// // Example 2
// // type MapTest2 = {
// //   [Key in keyof From]: {
// //     resolve: <Args> (args: Args) => From[Key],
// //     argsSchema: ArgsSchema<Args>
// //   }
// // }

// // function map2(mt: MapTest2): void {

// // }

// // map2({
// //   field: {
// //     resolve: (args: number) => "hello", 
// //     argsSchema: "number" 
// //   },
// //   anotherField: { 
// //     resolve: (args: string) => true, 
// //     argsSchema: "string" 
// //   }
// // })


// export type GetCompileTimeScalarType<Item> =
//   [Item] extends [typeof Date] 
//     ? Date
//     : [Item] extends [typeof Boolean]
//       ? boolean
//       : [Item] extends [typeof String]
//         ? string
//         : [Item] extends [IntOrFloat]
//           ? number
//         //   : [Item] extends [RegisteredEnum<{[key: string]: string}>]
//         // : [Item] extends [number]
//         //   ? IntOrFloat | RegisteredEnum<{[key: number]: string}>
//           : never

export type RuntimeArgsType<Item, B extends BooleanOrUndefined, A extends ArrayTrilean> =
  { 
    type: Item,
    nullable?: B,
    array?: A
  } 

// export type ArgsTypeFromRuntime<Item, Nullability extends BooleanOrUndefined, IsArray extends ArrayTrilean> =
//   GenerateReturnType<GetCompileTimeScalarType<Item>, Nullability, IsArray>

export type InferArgsFromSchema<Item, Nullability extends BooleanOrUndefined, IsArray extends ArrayTrilean> = 
  { 
    type: Item,
    nullable?: Nullability,
    array?: IsArray
  } 
    // & (
    //     [Item] extends [ScalarTypes]
    //     ? {}
    //     : {
    //         name?: string,
    //         runtimeTypes: InputRuntimeTypes<Item>
    //       }
    //   )


export type ArgsRuntimeTypes<Obj> = {
  [FieldName in keyof Obj]: 
    ScalarOrInput<Obj[FieldName]>
} 

export type ArgsSchema<O> = {
  type: Constructor<O>,
  runtimeSchema: ArgsRuntimeTypes<O>,
};

export type InferArgsForType<
  Type, 
  InferedArgs
> = {
  [FieldName in keyof InferedArgs]: 
    [FieldName] extends [keyof Type] 
      ? InferedArgs[FieldName]
      : never
}


// export type ResolverFunction<InferedArg, ReturnType> = 
//   [InferedArg] extends [RuntimeArgsType<infer RuntimeType, infer Nullability, infer IsArray>]
//     ? (args: GenerateReturnType<GetCompileTimeScalarType<RuntimeType>, Nullability, IsArray>) => ReturnType
//     : () => ReturnType


// export type ArgsThing<Type> = {
//   [Key in keyof Type]: any
// }

export type ArgsAndResolvers<ResolverFunction, Root, Context> =
  [ResolverFunction] extends [(args: infer ArgsRealType, root: infer X, context: Context) => infer ResponseType]
  ?
    {
      type: [IsCompileTimeScalarType<ResponseType>] extends [true]
        ? GetRuntimeScalarType<ResponseType>
        : Constructor<GetUnderlyingArrayType<ResponseType>>
    } 
    & (
        [null] extends [ResponseType]
          ? {
              nullable: true
            }
          : {
              nullable?: false
            }
      )
    & 
      (
        [undefined] extends [ArgsRealType] 
          ? {}
          : {
              args: {
                type: GetRuntimeScalarType<ArgsRealType>,
              } 
                & 
                  (
                    [null] extends [ArgsRealType] 
                      ? {
                          nullable: true
                        }
                      : {
                          nullable?: false
                      }
                  ),
            }
        )
      & {
          resolve: ResolverFunction,// (args: ArgsRealType) => ResponseType
        } 
      & 
        (
          [IsCompileTimeScalarType<ResponseType>] extends [true]
            ? {}
            : 
              {
                runtimeTypes: {
                  [Key in keyof GetUnderlyingArrayType<ResponseType>]:
                    ArgsAndResolvers<
                      (args: never, root: GetUnderlyingArrayType<ResponseType>, context: Context) => GetUnderlyingArrayType<ResponseType>[Key],
                      GetUnderlyingArrayType<ResponseType>,
                      Context
                    >
              }
            } 
        )
  : "Could not determine parameters from type"

export type ResolverFunction<Root, Context, Args, OutputType> =
  [unknown] extends [Args] 
    ? (root: Root, context: Context) => Promise<OutputType> 
    : { 
        resolve: (args: Args, root: Root, context: Context) => Promise<OutputType>,
        args: ArgsSchema<Args>
      }

export type Resolver<Root, Context, Args, OutputType> = 
  ({
    name?: string,
    description?: string, 
    deprecationReason?: string,
    type: GetRuntimeType<OutputType>
  })
    & GenerateNullabilityAndArrayRuntimeOptions<OutputType> 
    & (
      [unknown] extends [Args] 
        ? {
            resolve: (root: Root, context: Context) => Promise<OutputType> 
          }
        : { 
            resolve: (args: Args, root: Root, context: Context) => Promise<OutputType>,
            args: ArgsSchema<Args>
          }
    )
    & (
        [IsCompileTimeScalar<OutputType>] extends [false] 
          ? {
              runtimeTypes: {
                [FieldName in keyof OutputType]?: 
                  Resolver<OutputType, Context, unknown, OutputType[FieldName]>
              }
            }
          : {}
      )
  
// // Arbitrary properties are allowed.
// {
//   [Key in string]: 
//     keyof Obj extends Key
//       ? () => 
//         Nullable<ScalarTypes> 
//         | ScalarTypes 
//         | Nullable<RegisteredOutputObject<C, any>> 
//         | RegisteredOutputObject<C, any>
//         | RegisteredEnum<{[key: string]: string}>
//         | RegisteredEnum<{[key: number]: string}>
//         | RegisteredQuery<R, C, any, any>
//         | RegisteredResolver<R, C, any>
//       : never
// };

// export type ResolverInput<Root, Context, Args, OutputType> = 
//   ResolverCommon<Context, OutputType> 
//     & ResolverFunction<Root, Context, Args, OutputType>

export function resolver<Root, Context, Args, OutputType>(
  resolver: ResolverFunction<Root, Context, Args, OutputType>
): any
 {
  return resolver;
}

    ? [unknown] extends [ResolverFunction] 
      ? {resolve?: never, args?: never}
export type ValidateRuntimeField<Field, Root, Context> =
  GenerateNullabilityAndArrayRuntimeOptions<Field>

export type ValidateResolverRuntimeTypes<TypeConstructor, ResolverFunction, Root, Context> =
    [TypeConstructor] extends [ScalarTypes]
      ? {
          type: TypeConstructor,
          runtimeTypes?: never
        }
      : [unknown] extends [ResolverFunction]
        ? {
            type: TypeConstructor, 
            runtimeTypes: {
              [Key in keyof CompileTimeTypeFromConstructor<TypeConstructor>]?:
                ValidateRuntimeField<
                  CompileTimeTypeFromConstructor<TypeConstructor>[Key], 
                  CompileTimeTypeFromConstructor<TypeConstructor>, 
                  Context
                >
            }
          }
        : [ResolverFunction] extends [(first: infer First, second: infer Second, third: infer Third) => infer ReturnType]
          ? {
              type: Constructor<ReturnType>, 
              runtimeTypes: {
                [Key in keyof ReturnType]?:
                  ValidateRuntimeField<ReturnType[Key], ReturnType, Context>
              }
            }
          : {
              type: "Invalid Resolver"
            }

import { Args } from "./test"

// export type ValidateResolverFunction<ResolverFunction, ArgsType, Root> =
//   [unknown] extends [ArgsType]
//     ? [unknown] extends [ResolverFunction]
//       ? { resolve?: never, args?: never }
//       : {
//           resolve: (root: Root)
//             => [ResolverFunction] extends [(...args: infer X) => infer ReturnType]
//             ? ReturnType
//             : never,
//           args?: never
//         }
//     : {
//         resolve: (
//           args: ArgsType,
//           root: Root
//         ) => [ResolverFunction] extends [(...args: infer X) => infer ReturnType]
//           ? ReturnType
//           : never,
//         args: ArgsType
//       }

export type ValidateResolverFunction<ResolverFunction, ArgsType, Root> =
    [unknown] extends [ResolverFunction]
      ? unknown
      : [ResolverFunction] extends [(first: infer First, second: infer Second) => infer ReturnType]
        ? [unknown] extends [ArgsType]
          ? ((first: Root) => ReturnType) | (() => ReturnType)
          : ((first: ArgsType, second: Root) => ReturnType) | ((first: ArgsType) => ReturnType) | (() => ReturnType)
        : never
    // : {resolve?: never, args?: never}
  // [unknown] extends [ArgsType]
  //   ? [unknown] extends [ResolverFunction]
  //     ? { resolve?: never, args?: never }
  //     : {
  //         resolve: (root: Root)
  //           => [ResolverFunction] extends [(...args: infer X) => infer ReturnType]
  //           ? ReturnType
  //           : never,
  //         args?: never
  //       }
  //   : {
  //       resolve: (
  //         args: ArgsType,
  //         root: Root
  //       ) => [ResolverFunction] extends [(...args: infer X) => infer ReturnType]
  //         ? ReturnType
  //         : never,
  //       args: ArgsType
  //     }

type X = [{resolve: () => string, args: string}] extends [ValidateResolverFunction<(root: RootType) => string, string, RootType>]
  ? true : false

type Z = ValidateResolverFunction<(root: RootType) => string, string, RootType>

type Y = [() => string] extends [(arg: infer X) => string] ? X : never



export type ValidateResolver<Resolver, Root> =
  [Resolver] extends [{
    args?: infer ArgsType,
    resolve?: infer ResolverFunction
  }]
    ? [unknown] extends [ResolverFunction] 
      ? {resolve?: never, args?: never}
        : [ResolverFunction] extends [ValidateResolverFunction<ResolverFunction, ArgsType, Root>]
          ? [unknown] extends [ArgsType]
            ? {resolve: ResolverFunction, args?: never}
            : {resolve: ResolverFunction, args: ArgsType}
        : ["Invalid resolver function", ValidateResolverFunction<ResolverFunction, ArgsType, Root>]
    : "Can't infer type"


class RootType {}

function testValidate<X extends ValidateResolver<X, RootType>>(x: X) {
  return x;
}

testValidate({
});

testValidate({
  args: "test",
  resolve: (args: string) => {
    return `things`;
  }
});

testValidate({
  resolve: () => {
    return `things`;
  }
});

testValidate({
  // Errors out correctly
  resolve: (args: string, root: RootType) => {
    return `things`;
  }
});

testValidate({
  args: "test",
  // This should error out, since first parameter is not args: string.
  resolve: (root: RootType) => {
    return `things`;
  }
});
graphql_test/test.ts(197,7): error TS2322: Type '{ objectName: string; resolve: (args: Args) => Promise<Test>; argsFields: { readonly stringField: { readonly type: ScalarTypes.STRING; }; readonly booleanField: { readonly type: ScalarTypes.BOOLEAN; }; readonly dateField: { readonly type: ScalarTypes.DATE; }; readonly numberField: { readonly type: ScalarTypes.INT; }; readonly nullableField: { readonly type: ScalarTypes.STRING; readonly nullable: true; }; readonly arrayField: { readonly type: ScalarTypes.STRING; readonly array: true; }; readonly nullableArrayField: { readonly type: ScalarTypes.STRING; readonly nullable: true; readonly array: true; }; readonly nullableItemsField: { readonly type: ScalarTypes.STRING; readonly array: "nullable_items"; }; readonly inputObjectField: { readonly inputFields: { readonly stringField: { readonly type: ScalarTypes.STRING; }; readonly booleanField: { readonly type: ScalarTypes.BOOLEAN; }; readonly dateField: { readonly type: ScalarTypes.DATE; }; readonly numberField: { readonly type: ScalarTypes.INT; }; readonly nullableField: { readonly type: ScalarTypes.STRING; readonly nullable: true; }; readonly arrayField: { readonly type: ScalarTypes.STRING; readonly array: true; }; readonly nullableArrayField: { readonly type: ScalarTypes.STRING; readonly nullable: true; readonly array: true; }; readonly nullableItemsField: { readonly type: ScalarTypes.STRING; readonly array: "nullable_items"; }; }; }; readonly inputObjectArray: { readonly array: true; readonly inputFields: { readonly stringField: { readonly type: ScalarTypes.STRING; }; readonly booleanField: { readonly type: ScalarTypes.BOOLEAN; }; readonly dateField: { readonly type: ScalarTypes.DATE; }; readonly numberField: { readonly type: ScalarTypes.INT; }; readonly nullableField: { readonly type: ScalarTypes.STRING; readonly nullable: true; }; readonly arrayField: { readonly type: ScalarTypes.STRING; readonly array: true; }; readonly nullableArrayField: { readonly type: ScalarTypes.STRING; readonly nullable: true; readonly array: true; }; readonly nullableItemsField: { readonly type: ScalarTypes.STRING; readonly array: "nullable_items"; }; }; }; readonly inputObjectNullableItems: { readonly array: "nullable_items"; readonly inputFields: { readonly stringField: { readonly type: ScalarTypes.STRING; }; readonly booleanField: { readonly type: ScalarTypes.BOOLEAN; }; readonly dateField: { readonly type: ScalarTypes.DATE; }; readonly numberField: { readonly type: ScalarTypes.FLOAT; }; readonly nullableField: { readonly type: ScalarTypes.STRING; readonly nullable: true; }; readonly arrayField: { readonly type: ScalarTypes.STRING; readonly array: true; }; readonly nullableArrayField: { readonly type: ScalarTypes.STRING; readonly nullable: true; readonly array: true; }; readonly nullableItemsField: { readonly type: ScalarTypes.STRING; readonly array: "nullable_items"; }; }; }; readonly nullableInputObjectField: { readonly nullable: true; readonly inputFields: { readonly stringField: { readonly type: ScalarTypes.STRING; }; readonly booleanField: { readonly type: ScalarTypes.BOOLEAN; }; readonly dateField: { readonly type: ScalarTypes.DATE; }; readonly numberField: { readonly type: ScalarTypes.INT; }; readonly nullableField: { readonly type: ScalarTypes.STRING; readonly nullable: true; }; readonly arrayField: { readonly type: ScalarTypes.STRING; readonly array: true; }; readonly nullableArrayField: { readonly type: ScalarTypes.STRING; readonly nullable: true; readonly array: true; }; readonly nullableItemsField: { readonly type: ScalarTypes.STRING; readonly array: "nullable_items"; }; }; }; readonly nullableInputObjectNullableItems: { readonly nullable: true; readonly array: "nullable_items"; readonly inputFields: { readonly stringField: { readonly type: ScalarTypes.STRING; }; readonly booleanField: { readonly type: ScalarTypes.BOOLEAN; }; readonly dateField: { readonly type: ScalarTypes.DATE; }; readonly numberField: { readonly type: ScalarTypes.INT; }; readonly nullableField: { readonly type: ScalarTypes.STRING; readonly nullable: true; }; readonly arrayField: { readonly type: ScalarTypes.STRING; readonly array: true; }; readonly nullableArrayField: { readonly type: ScalarTypes.STRING; readonly nullable: true; readonly array: true; }; readonly nullableItemsField: { readonly type: ScalarTypes.STRING; readonly array: "nullable_items"; }; }; }; }; objectFields: { stringField: { type: ScalarTypes.STRING; resolve: (root: Test) => Promise<string>; }; booleanField: { type: ScalarTypes.BOOLEAN; }; dateField: { type: ScalarTypes.DATE; }; intField: { type: ScalarTypes.INT; }; floatField: { type: ScalarTypes.FLOAT; }; relatedField: { objectName: string; objectFields: { testField: { type: ScalarTypes.STRING; }; }; resolve: (root: Test) => Promise<RelatedClass>; }; arrayRelatedField: { objectName: string; objectFields: { asdfField: { type: ScalarTypes.STRING; }; }; array: true; resolve: () => Promise<ArrayRelatedClass[]>; }; arrayField: { type: ScalarTypes.STRING; array: true; resolve: (root: Test) => Promise<string[]>; }; nullableArrayField: { type: ScalarTypes.STRING; nullable: true; array: true; resolve: (root: Test) => Promise<string[] | null>; }; queriedField: { objectName: string; objectFields: { testField: { type: ScalarTypes.STRING; }; }; argsFields: { readonly stringField: { readonly type: ScalarTypes.STRING; }; readonly booleanField: { readonly type: ScalarTypes.BOOLEAN; }; readonly dateField: { readonly type: ScalarTypes.DATE; }; readonly numberField: { readonly type: ScalarTypes.INT; }; readonly nullableField: { readonly type: ScalarTypes.STRING; readonly nullable: true; }; readonly arrayField: { readonly type: ScalarTypes.STRING; readonly array: true; }; readonly nullableArrayField: { readonly type: ScalarTypes.STRING; readonly nullable: true; readonly array: true; }; readonly nullableItemsField: { readonly type: ScalarTypes.STRING; readonly array: "nullable_items"; }; readonly inputObjectField: { readonly inputFields: { readonly stringField: { readonly type: ScalarTypes.STRING; }; readonly booleanField: { readonly type: ScalarTypes.BOOLEAN; }; readonly dateField: { readonly type: ScalarTypes.DATE; }; readonly numberField: { readonly type: ScalarTypes.INT; }; readonly nullableField: { readonly type: ScalarTypes.STRING; readonly nullable: true; }; readonly arrayField: { readonly type: ScalarTypes.STRING; readonly array: true; }; readonly nullableArrayField: { readonly type: ScalarTypes.STRING; readonly nullable: true; readonly array: true; }; readonly nullableItemsField: { readonly type: ScalarTypes.STRING; readonly array: "nullable_items"; }; }; }; readonly inputObjectArray: { readonly array: true; readonly inputFields: { readonly stringField: { readonly type: ScalarTypes.STRING; }; readonly booleanField: { readonly type: ScalarTypes.BOOLEAN; }; readonly dateField: { readonly type: ScalarTypes.DATE; }; readonly numberField: { readonly type: ScalarTypes.INT; }; readonly nullableField: { readonly type: ScalarTypes.STRING; readonly nullable: true; }; readonly arrayField: { readonly type: ScalarTypes.STRING; readonly array: true; }; readonly nullableArrayField: { readonly type: ScalarTypes.STRING; readonly nullable: true; readonly array: true; }; readonly nullableItemsField: { readonly type: ScalarTypes.STRING; readonly array: "nullable_items"; }; }; }; readonly inputObjectNullableItems: { readonly array: "nullable_items"; readonly inputFields: { readonly stringField: { readonly type: ScalarTypes.STRING; }; readonly booleanField: { readonly type: ScalarTypes.BOOLEAN; }; readonly dateField: { readonly type: ScalarTypes.DATE; }; readonly numberField: { readonly type: ScalarTypes.FLOAT; }; readonly nullableField: { readonly type: ScalarTypes.STRING; readonly nullable: true; }; readonly arrayField: { readonly type: ScalarTypes.STRING; readonly array: true; }; readonly nullableArrayField: { readonly type: ScalarTypes.STRING; readonly nullable: true; readonly array: true; }; readonly nullableItemsField: { readonly type: ScalarTypes.STRING; readonly array: "nullable_items"; }; }; }; readonly nullableInputObjectField: { readonly nullable: true; readonly inputFields: { readonly stringField: { readonly type: ScalarTypes.STRING; }; readonly booleanField: { readonly type: ScalarTypes.BOOLEAN; }; readonly dateField: { readonly type: ScalarTypes.DATE; }; readonly numberField: { readonly type: ScalarTypes.INT; }; readonly nullableField: { readonly type: ScalarTypes.STRING; readonly nullable: true; }; readonly arrayField: { readonly type: ScalarTypes.STRING; readonly array: true; }; readonly nullableArrayField: { readonly type: ScalarTypes.STRING; readonly nullable: true; readonly array: true; }; readonly nullableItemsField: { readonly type: ScalarTypes.STRING; readonly array: "nullable_items"; }; }; }; readonly nullableInputObjectNullableItems: { readonly nullable: true; readonly array: "nullable_items"; readonly inputFields: { readonly stringField: { readonly type: ScalarTypes.STRING; }; readonly booleanField: { readonly type: ScalarTypes.BOOLEAN; }; readonly dateField: { readonly type: ScalarTypes.DATE; }; readonly numberField: { readonly type: ScalarTypes.INT; }; readonly nullableField: { readonly type: ScalarTypes.STRING; readonly nullable: true; }; readonly arrayField: { readonly type: ScalarTypes.STRING; readonly array: true; }; readonly nullableArrayField: { readonly type: ScalarTypes.STRING; readonly nullable: true; readonly array: true; }; readonly nullableItemsField: { readonly type: ScalarTypes.STRING; readonly array: "nullable_items"; }; }; }; }; resolve: (args: Args, root: Test) => Promise<RelatedClass>; }; nullableRelatedField: { objectName: string; objectFields: { testField: { type: ScalarTypes.STRING; }; }; nullable: true; resolve: (root: Test) => Promise<RelatedClass | null>; }; }; }' is not assignable to type '{ description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { objectName: string; objectFields: { stringField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { type: ScalarTypes.STRING; objectFields?: "Runtime types not used when return type is scalar." | undefined; objectName?: undefined; } & { resolve: (root: Test) => Promise<string>; argsFields?: undefined; } & { nullable?: false | undefined; } & { array?: false | undefined; }; booleanField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { type: ScalarTypes; objectFields?: undefined; objectName?: undefined; } & { nullable?: unknown; array?: unknown; }; dateField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { type: ScalarTypes; objectFields?: undefined; objectName?: undefined; } & { nullable?: unknown; array?: unknown; }; intField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { type: ScalarTypes; objectFields?: undefined; objectName?: undefined; } & { nullable?: unknown; array?: unknown; }; floatField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { type: ScalarTypes; objectFields?: undefined; objectName?: undefined; } & { nullable?: unknown; array?: unknown; }; relatedField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { objectName: string; objectFields: { testField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { type: ScalarTypes; objectFields?: undefined; objectName?: undefined; } & { nullable?: unknown; array?: unknown; }; }; } & { resolve: (root: Test) => Promise<RelatedClass>; argsFields?: undefined; } & { nullable?: false | undefined; } & { array?: false | undefined; }; arrayRelatedField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { objectName: string; objectFields: { asdfField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { type: ScalarTypes; objectFields?: undefined; objectName?: undefined; } & { nullable?: unknown; array?: unknown; }; }; } & { resolve: () => Promise<ArrayRelatedClass[]>; } & { argsFields?: undefined; } & { nullable?: false | undefined; } & { array: true; }; arrayField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { type: ScalarTypes.STRING; objectFields?: "Runtime types not used when return type is scalar." | undefined; objectName?: undefined; } & { resolve: (root: Test) => Promise<string[]>; argsFields?: undefined; } & { nullable?: false | undefined; } & { array: true; }; nullableArrayField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { type: ScalarTypes.STRING; objectFields?: "Runtime types not used when return type is scalar." | undefined; objectName?: undefined; } & { resolve: (root: Test) => Promise<string[] | null>; argsFields?: undefined; } & { nullable: true; } & { array: true; }; queriedField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { objectName: string; objectFields: { testField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { type: ScalarTypes; objectFields?: undefined; objectName?: undefined; } & { nullable?: unknown; array?: unknown; }; }; } & { resolve: (args: Args, root: Test) => Promise<RelatedClass>; } & { argsFields: ValidateInputRuntimeTypes<Args>; } & { nullable?: false | undefined; } & { array?: false | undefined; }; nullableRelatedField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { objectName: string; objectFields: { testField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { type: ScalarTypes; objectFields?: undefined; objectName?: undefined; } & { nullable?: unknown; array?: unknown; }; }; } & { resolve: (root: Test) => Promise<RelatedClass | null>; argsFields?: undefined; } & { nullable: true; } & { array?: false | undefined; }; }; } & ["Should not happen, make github issue.", (args: Args) => Promise<Test>] & { nullable?: false | undefined; } & { array?: false | undefined; }'.
  { 
    description?: unknown; deprecationReason?: unknown; alias?: unknown; } 
& { objectName: string; objectFields: { stringField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } 
& { type: ScalarTypes.STRING; objectFields?: "Runtime types not used when return type is scalar." | undefined; objectName?: undefined; } 
& { resolve: (root: Test) => Promise<string>; argsFields?: undefined; } 
& { nullable?: false | undefined; } 
& { array?: false | undefined; }; booleanField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } 
& { type: ScalarTypes; objectFields?: undefined; objectName?: undefined; } 
& { nullable?: unknown; array?: unknown; }; dateField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } 
& { type: ScalarTypes; objectFields?: undefined; objectName?: undefined; } 
& { nullable?: unknown; array?: unknown; }; intField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } 
& { type: ScalarTypes; objectFields?: undefined; objectName?: undefined; } 
& { nullable?: unknown; array?: unknown; }; floatField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } 
& { type: ScalarTypes; objectFields?: undefined; objectName?: undefined; } 
& { nullable?: unknown; array?: unknown; }; relatedField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } 
& { objectName: string; objectFields: { testField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } 
& { type: ScalarTypes; objectFields?: undefined; objectName?: undefined; } 
& { nullable?: unknown; array?: unknown; }; }; } 
& { resolve: (root: Test) => Promise<RelatedClass>; argsFields?: undefined; } 
& { nullable?: false | undefined; } 
& { array?: false | undefined; }; arrayRelatedField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } 
& { objectName: string; objectFields: { asdfField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } 
& { type: ScalarTypes; objectFields?: undefined; objectName?: undefined; } 
& { nullable?: unknown; array?: unknown; }; }; } 
& { resolve: () => Promise<ArrayRelatedClass[]>; } 
& { argsFields?: undefined; } 
& { nullable?: false | undefined; } 
& { array: true; }; arrayField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } 
& { type: ScalarTypes.STRING; objectFields?: "Runtime types not used when return type is scalar." | undefined; objectName?: undefined; } 
& { resolve: (root: Test) => Promise<string[]>; argsFields?: undefined; } 
& { nullable?: false | undefined; } 
& { array: true; }; nullableArrayField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } 
& { type: ScalarTypes.STRING; objectFields?: "Runtime types not used when return type is scalar." | undefined; objectName?: undefined; } 
& { resolve: (root: Test) => Promise<string[] | null>; argsFields?: undefined; } 
& { nullable: true; } 
& { array: true; }; queriedField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } 
& { objectName: string; objectFields: { testField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } 
& { type: ScalarTypes; objectFields?: undefined; objectName?: undefined; } 
& { nullable?: unknown; array?: unknown; }; }; } 
& { resolve: (args: Args, root: Test) => Promise<RelatedClass>; } 
& { argsFields: ValidateInputRuntimeTypes<Args>; } 
& { nullable?: false | undefined; } 
& { array?: false | undefined; }; nullableRelatedField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } 
& { objectName: string; objectFields: { testField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } 
& { type: ScalarTypes; objectFields?: undefined; objectName?: undefined; } 
& { nullable?: unknown; array?: unknown; }; }; } 
& { resolve: (root: Test) => Promise<RelatedClass | null>; argsFields?: undefined; } 
& { nullable: true; } 
& { array?: false | undefined; }; }; } 
& ["Should not happen, make github issue.", (args: Args) => Promise<Test>] 
& { nullable?: false | undefined; } 
& { array?: false | undefined; }'.

    "@graphql-tools/delegate": "^7.0.8",
    "@graphql-tools/merge": "^6.2.7",
    "@types/express-session": "^1.17.3",
    "@types/graphql-fields": "^1.3.3",
    "@types/node": "^14.14.14",
    "@types/pluralize": "^0.0.29",
    "axios": "^0.21.4",
    "body-parser": "^1.19.1",
    "child-process-promise": "^2.2.1",
    "class-transformer": "^0.4.0",
    "cors": "^2.8.5",
    "dedent": "^0.7.0",
    "dotenv": "^8.2.0",
    "express": "^4.17.1",
    "express-session": "^1.17.1",
    "graphql": "^15.4.0",
    "graphql-codegen-apollo-next-ssr": "^1.3.0",
    "graphql-fields": "^2.0.3",
    "graphql-middleware": "^6.0.0",
    "graphql-request": "^3.4.0",
    "graphql-type-json": "^0.3.2",
    "lodash": "^4.17.20",
    "pluralize": "^8.0.0",
    "reflect-metadata": "^0.1.13",
    "type-graphql": "^1.1.1",
    "yarn": "^1.22.17"
  },
  "devDependencies": {
    "@graphql-codegen/cli": "1.20.0",
    "@graphql-codegen/introspection": "^1.18.1",
    "@graphql-codegen/typescript": "^1.20.0",
    "@graphql-codegen/typescript-graphql-request": "3.0.0",
    "@graphql-codegen/typescript-operations": "^1.17.13",
    "@types/child-process-promise": "^2.2.1",
    "@types/express": "^4.17.9",
    "@types/express-graphql": "^0.9.0",
    "@types/graphql": "^14.5.0",
    "@types/graphql-relay": "^0.6.0",
    "class-validator": "^0.12.2",
    "ts-node": "^9.1.1",
    "ts-node-dev": "^1.1.1",
    "typescript": "^4.6.2"
  }
}


schema.test.ts:228:9 - error TS2322: Type '{ objectName: string; objectFields: { testField: { type: ScalarTypes.STRING; }; }; resolve: (root: Test) => Promise<RelatedClass>; }' is not assignable to type 
'{ description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { objectName: string; objectFields: { testField: ScalarTypes.STRING | ({ description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { type: ScalarTypes.STRING; objectName?: undefined; objectFields?: undefined; } & { resolve?: undefined; argsFields?: undefined; } & { nullable?: false | undefined; } & { array?: false | undefined; }); }; } & ValidateInputRuntimeTypes<Test> & {
resolve: ((args: Test, root: Test, context: any) => RelatedClass) | ((args: Test, root: Test, context: any) => Promise<RelatedClass>); } & { nullable?: false | undefined; } & { array?: false | undefined; }'.
  Type '{ objectName: string; objectFields: { testField: { type: ScalarTypes.STRING; }; }; resolve: (root: Test) => Promise<RelatedClass>; }' is missing the following properties from type 'ValidateInputRuntimeTypes<Test>': stringField, booleanField, dateField, intField, and 7 more.

228         relatedField: {
            ~~~~~~~~~~~~

  schema.test.ts:228:9
    228         relatedField: {
                ~~~~~~~~~~~~~~~
    229           objectName: "RelatedClass",
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ...
    237           },
        ~~~~~~~~~~~~
    238         },
        ~~~~~~~~~
    The expected type comes from property 'relatedField' which is declared here on type '{ stringField: ScalarTypes.STRING | ({ description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { type: ScalarTypes.STRING; objectName?: undefined; objectFields?:
undefined; } & { resolve?: undefined; argsFields?: undefined; } & { nullable?: false | undefined; } & { array?: false | undefined; }); booleanField: { resolve: ["Can't infer type", ScalarTypes, Test, any]; }; dateField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { type: ScalarTypes.DATE; objectName?: undefined; objectFields?: undefined; } & { resolve?: undefined; argsFields?: undefined; } & { nullable: true; } & { array?: false | undefined; }; intField: ScalarTypes.FLOAT | ScalarTypes.INT | ({ description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { type: ScalarTypes.FLOAT | ScalarTypes.INT; objectName?: undefined; objectFields?: undefined; } & { resolve?: undefined; argsFields?: undefined; } & { nullable?: false | undefined; } & { array?: false | undefined; }); floatField: ScalarTypes.FLOAT | ScalarTypes.INT | ({ description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { type: ScalarTypes.FLOAT | ScalarTypes.INT; objectName?: undefined; objectFields?: undefined; } & { resolve?: undefined; argsFields?: undefined; } & { nullable?: false | undefined; } & { array?: false | undefined; }); relatedField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { objectName: string; objectFields: { testField: ScalarTypes.STRING | ({ description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { type: ScalarTypes.STRING; objectName?: undefined; objectFields?: undefined; } & { resolve?: undefined; argsFields?: undefined; } & { nullable?: false | undefined; } & { array?: false | undefined; }); };
} & ValidateInputRuntimeTypes<Test> & { resolve: ((args: Test, root: Test, context: any) => RelatedClass) | ((args: Test, root: Test,
context: any) => Promise<RelatedClass>); } & { nullable?: false | undefined; } & { array?: false | undefined; }; arrayRelatedField: {
description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { objectName: string; objectFields: { asdfField: ScalarTypes.STRING | ({ description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { type: ScalarTypes.STRING; objectName?: undefined; objectFields?: undefined; } & { resolve?: undefined; argsFields?: undefined; } & { nullable?: false | undefined; } & { array?: false | undefined; }); }; } & ValidateInputRuntimeTypes<unknown> & { resolve: ((args: unknown, root: Test, context: any) => ArrayRelatedClass[]) | ((args: unknown, root: Test, context: any) => Promise<ArrayRelatedClass[]>); } & { nullable?: false | undefined; } & { array: true; }; arrayField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { type: ScalarTypes.STRING; objectName?: undefined; objectFields?: undefined; } & ValidateInputRuntimeTypes<Test> & { resolve: ((args: Test, root: Test, context: any) => string[]) | ((args: Test, root: Test, context: any) => Promise<string[]>); } & { nullable?: false | undefined; } & { array: true; }; nullableArrayField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { type: ScalarTypes.STRING; objectName?:
undefined; objectFields?: undefined; } & ValidateInputRuntimeTypes<Test> & { resolve: ((args: Test, root: Test, context: any) => string[] | null) | ((args: Test, root: Test, context: any) => Promise<string[] | null>); } & { nullable: true; } & { array: true; }; queriedField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { objectName: string; objectFields: { testField: ScalarTypes.STRING | ({ description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { type: ScalarTypes.STRING; objectName?: undefined; objectFields?: undefined; } & { resolve?: undefined; argsFields?: undefined; } & { nullable?: false | undefined; } & { array?: false | undefined; }); }; } & ValidateInputRuntimeTypes<Args> & { resolve: ((args: Args, root: Test, context: any) => RelatedClass) | ((args: Args, root: Test, context: any) => Promise<RelatedClass>); } & { nullable?: false | undefined; } & { array?: false | undefined; }; nullableRelatedField: { description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { objectName: string; objectFields: { testField: ScalarTypes.STRING | ({ description?: unknown; deprecationReason?: unknown; alias?: unknown; } & { type: ScalarTypes.STRING; objectName?: undefined; objectFields?: undefined; } & { resolve?: undefined; argsFields?: undefined; } & { nullable?: false | undefined; } & { array?: false | undefined; }); }; } & ValidateInputRuntimeTypes<Test> & { resolve: ((args: Test, root: Test, context: any) => RelatedClass | null) | ((args: Test, root: Test, context: any) => Promise<RelatedClass | null>); } & { nullable: true;
} & { array?: false | undefined; }; }'

export class Test {
  constructor(
    public stringField: string,
    public booleanField: boolean,
    public dateField: Date | null,
    public intField: number,
    public floatField: number,
    public relatedField: RelatedClass,
    public arrayRelatedField: ArrayRelatedClass[],
    public stringEnumField: StringEnum,
    public numberEnumField: IntEnum,
    public arrayField: string[],
    public nullableArrayField: string[] | null,
    public queriedField: RelatedClass,
    public nullableRelatedField: RelatedClass | null
  ) {
  }
}

export class RelatedClass {
  constructor(public testField: string) {
  }
}

export class ArrayRelatedClass {
  asdfField: string;

  constructor(asdfField: string) {
    this.asdfField = asdfField;
  }
}

export class TestInputObject {
  constructor(
    public stringField: string,
    public booleanField: boolean,
    public dateField: Date,
    public numberField: number,
    public nullableField: string | null,
    public arrayField: string[],
    public nullableArrayField: string[] | null,
    public nullableItemsField: (string | null)[]
  ) { }
}

export class Args {
  constructor(
    public stringField: string,
    public booleanField: boolean,
    public dateField: Date,
    public numberField: number,
    public nullableField: string | null,
    public arrayField: string[],
    public nullableArrayField: string[] | null,
    public nullableItemsField: (string | null)[],
    public inputObjectField: TestInputObject,
    public nullableInputObjectField: TestInputObject | null,
    public inputObjectArray: TestInputObject[],
    public inputObjectNullableItems: (TestInputObject | null)[],
    public nullableInputObjectNullableItems: (TestInputObject | null)[] | null,
  ) {
  }
}

enum StringEnum {
  erer = "erer",
  asdf = "asdf"
}

enum IntEnum {
  first,
  second
}

const testObject = new Test(
  "asdf",
  false,
  new Date(),
  1,
  1.0,
  new RelatedClass("qwer"),
  [new ArrayRelatedClass("test")],
  StringEnum.asdf,
  IntEnum.second,
  ["goodbye"],
  ["hello", "world"],
  new RelatedClass("hello"),
  null
);


export async function getTest(args: Args): Promise<Test> {
  return testObject;
}

export class ChildArgs {
  constructor(
    public field: string
  ) {

  }
}

export class NestedChildArgs {
  constructor(
    public field: string,
    public nullableField: string | null,
    public arrayField: string[] | null,
    public childArgs: ChildArgs,
    public arrayOfChildArgs: (ChildArgs | null)[] | null
  ) {

  }
}

const registeredArgs =
{
      stringField: { type: ScalarTypes.STRING },
      booleanField: { type: ScalarTypes.BOOLEAN },
      dateField: { type: ScalarTypes.DATE },
      numberField: { type: ScalarTypes.INT },
      nullableField: { type: ScalarTypes.STRING, nullable: true },
      arrayField: { type: ScalarTypes.STRING, array: true },
      nullableArrayField: { type: ScalarTypes.STRING, nullable: true, array: true },
      nullableItemsField: { type: ScalarTypes.STRING, array: "nullable_items" },
      inputObjectField: {
        inputName: 'TestInputObject',
        inputFields: {
          stringField: { type: ScalarTypes.STRING },
          booleanField: { type: ScalarTypes.BOOLEAN },
          dateField: { type: ScalarTypes.DATE },
          numberField: { type: ScalarTypes.INT },
          nullableField: { type: ScalarTypes.STRING, nullable: true },
          arrayField: { type: ScalarTypes.STRING, array: true },
          nullableArrayField: { type: ScalarTypes.STRING, nullable: true, array: true },
          nullableItemsField: { type: ScalarTypes.STRING, array: "nullable_items" },
        }
      },
      inputObjectArray: {
        array: true,
        inputName: 'TestInputObject',
        inputFields: {
          stringField: { type: ScalarTypes.STRING },
          booleanField: { type: ScalarTypes.BOOLEAN },
          dateField: { type: ScalarTypes.DATE },
          numberField: { type: ScalarTypes.INT },
          nullableField: { type: ScalarTypes.STRING, nullable: true },
          arrayField: { type: ScalarTypes.STRING, array: true },
          nullableArrayField: { type: ScalarTypes.STRING, nullable: true, array: true },
          nullableItemsField: { type: ScalarTypes.STRING, array: "nullable_items" },
        }
      },
      inputObjectNullableItems: {
        array: "nullable_items",
        inputName: 'TestInputObject',
        inputFields: {
          stringField: { type: ScalarTypes.STRING },
          booleanField: { type: ScalarTypes.BOOLEAN },
          dateField: { type: ScalarTypes.DATE },
          numberField: { type: ScalarTypes.FLOAT },
          nullableField: { type: ScalarTypes.STRING, nullable: true },
          arrayField: { type: ScalarTypes.STRING, array: true },
          nullableArrayField: { type: ScalarTypes.STRING, nullable: true, array: true },
          nullableItemsField: { type: ScalarTypes.STRING, array: "nullable_items" },
        }
      },
      nullableInputObjectField: {
        nullable: true,
        inputName: 'TestInputObject',
        inputFields: {
          stringField: { type: ScalarTypes.STRING },
          booleanField: { type: ScalarTypes.BOOLEAN },
          dateField: { type: ScalarTypes.DATE },
          numberField: { type: ScalarTypes.INT },
          nullableField: { type: ScalarTypes.STRING, nullable: true },
          arrayField: { type: ScalarTypes.STRING, array: true },
          nullableArrayField: { type: ScalarTypes.STRING, nullable: true, array: true },
          nullableItemsField: { type: ScalarTypes.STRING, array: "nullable_items" }
        }
      },
      nullableInputObjectNullableItems: {
        nullable: true,
        array: "nullable_items",
        inputName: 'TestInputObject',
        inputFields: {
          stringField: { type: ScalarTypes.STRING },
          booleanField: { type: ScalarTypes.BOOLEAN },
          dateField: { type: ScalarTypes.DATE },
          numberField: { type: ScalarTypes.INT },
          nullableField: { type: ScalarTypes.STRING, nullable: true },
          arrayField: { type: ScalarTypes.STRING, array: true },
          nullableArrayField: { type: ScalarTypes.STRING, nullable: true, array: true },
          nullableItemsField: { type: ScalarTypes.STRING, array: "nullable_items" }
        }
      }
    } as const
  ;

const context = {} as any;

class Context {

}

const relatedObject = 
  {
    objectName: "RelatedClass",
    objectFields: {
      testField: {
        type: ScalarTypes.STRING
      }
    },
  } as const;

// schema(
//   context, 
//   {
//   queries: {
//     testQuery: {
//       resolve: getTest,
//       argsFields: registeredArgs,
//       type: {
//         objectName: "Test",
//         objectFields: {
//           additionalFieldScalar: {
//             type: {
//               objectName: "AdditionalRelatedClass",
//               objectFields: {
//                 testField: ScalarTypes.STRING
//               },
//             },
//             resolve: async () => {
//               return new RelatedClass("additional field test");
//             }
//           },
//           additionalFieldScalarObject: {
//             type: ScalarTypes.STRING,
//             resolve: async () => {
//               return "asdf"
//             }
//           },
//           // stringField: resolver(Test, Context, {
//           //   type: ScalarTypes.STRING,
//           //   resolve: async (root: Test) => {
//           //     return `${root.stringField} is being resolved`;
//           //   }
//           // }),
//           booleanField: ScalarTypes.BOOLEAN,
//           dateField: { 
//             type: ScalarTypes.DATE, 
//             nullable: true 
//           },
//           stringEnumField: { enum: StringEnum },
//           numberEnumField: { 
//             type: {enum: IntEnum},
//             resolve: (): IntEnum => {
//               return IntEnum.first;
//             }
//           },
//           intField: { type: ScalarTypes.INT },
//           floatField: { type: ScalarTypes.FLOAT },
//           relatedField: {
//             type: {
//               objectName: "RelatedClass",
//               objectFields: {
//                 testField: {
//                   type: ScalarTypes.STRING
//                 }
//               },
//             },
//             resolve: async (root: Test) => {
//               return new RelatedClass(`${root.intField} times`);
//             },
//           },
//           arrayRelatedField: {
//             type: {
//               objectName: "ArrayRelatedClass",
//               objectFields: {
//                 asdfField: { type: ScalarTypes.STRING }
//               },
//             },
//             array: true,
//             resolve: async () => {
//               return [new ArrayRelatedClass("array related")];
//             },
//           },
//           arrayField: {
//             type: ScalarTypes.STRING,
//             array: true,
//             resolve: async (root: Test) => {
//               return root.arrayField;
//             }
//           },
//           nullableArrayField: {
//             type: ScalarTypes.STRING,
//             nullable: true,
//             array: true,
//             resolve: async (root: Test): Promise<string[] | null> => {
//               return root.nullableArrayField
//             }
//           },
//           queriedField: {
//             type: {
//               objectName: "RelatedClass",
//               objectFields: {
//                 testField: { type: ScalarTypes.STRING }
//               },
//             },
//             argsFields: registeredArgs,
//             resolve: async (args: Args, root: Test): Promise<RelatedClass> => {
//               return root.queriedField;
//             }
//           },
//           nullableRelatedField: {
//             type: relatedObject,
//             nullable: true,
//             resolve: async (root: Test) => {
//               return root.nullableRelatedField;
//             },
//           }
//         }
//       }
//     }
//   }
// });